#include <functional>
#include <string>
#include <tuple>
#include <iomanip>
#include <ctime>
#include <cassert>
#include <sstream>
#include <fstream>
#include <iostream>
#include <thread>

using kernel_function = std::function<std::string(uint, uint, uint, float *, float *, float *)>;

std::string run_fun_kernel(uint M, uint N, uint K, float *d_a, float *d_b, float *d_c)
{
	std::this_thread::sleep_for(std::chrono::milliseconds(100));
	return "Fun";
}

class Gen
{
public:
	Gen(): os_(std::cout)
	{
	}

	Gen(std::string file_name): os_(fd_), file_name_(file_name)
	{
		std::string py_file_name = file_name_ + ".py";
		fd_.open(py_file_name);
		if(! fd_.is_open())
		{
			// TODO: error handle.
		}
	}
public:
	void generate_comment(std::vector<std::string> const &msgs)
	{
		// generate divide line.
		for(int i = 0; i < 100; ++i) os_ << "#";
		os_ << std::endl;
		os_ << "# " << "Automatic generated by Gen(), DONNT EDIT" << std::endl;
		for(auto msg: msgs)
			os_ << "# " << msg << std::endl;
		// generate divide line.
		for(int i = 0; i < 100; ++i) os_ << "#";
		os_ << std::endl;
		os_ << std::endl;
	}

	void generate_numpy_header()
	{
		generate_comment({current_time(), "Gen class for visualize kernel result"});
		os_ << "import numpy as np" << std::endl
            << "import matplotlib.pyplot as plt" << std::endl
			<< "from matplotlib.pyplot import MultipleLocator" << std::endl
		;
	}

	void generate_array(std::vector<float> &v)
	{
		os_ << "[";
		for(int i = 0; i < v.size(); i ++)
		{
			os_ << v[i];
			if(i != v.size() - 1)
				os_ << ", ";
		}
		os_ << "]";
	}

	void generate_numpy_array(std::vector<float> &v)
	{
		os_ << "np.array(";
		generate_array(v);
		os_ << ")";
	}

	// the parameter is the shape and the related time it costs,
	// so there should have at least two parameter.
	// First one is the vector of shape vector, another is vector of the time vector.
	void generate_python_script(std::vector<std::tuple<uint, uint, uint> > shapes, std::vector<float> cost_time)
	{
		assert(("Shape size should be same as cost_time", shapes.size() == cost_time.size()));
		generate_numpy_header();	
	}

	void gen(
		std::vector<kernel_function> kernels,
		float *d_a, float *d_b, float *d_c, std::vector<std::tuple<uint, uint, uint>> shapes)
	{
		// Timer t;
		// loop_time.
		// run kernels
		const uint loop_time = 5;

		std::vector<float> cost_times;

		// for all shape
		for(auto shape: shapes)
		{
			// for all kernels.
			for(auto kernel: kernels)
			{
				uint M = std::get<0>(shape);
				uint N = std::get<1>(shape);
				uint K = std::get<2>(shape);

				std::string kernel_name = kernel(M, N, K, d_a, d_b, d_c);

				// Timer t;
				// t.start();

				for(int i = 0; i < loop_time; i ++)
				{
					kernel(M, N, K, d_a, d_b, d_c);
				}
				// t.stop();
				cost_times.push_back(0.0f);
			}
		}
		generate_python_script(shapes, cost_times);
	}
public:
	static std::string current_time()
	{
	    // Get current time
	    std::time_t now = std::time(nullptr);
	    std::tm* localTime = std::localtime(&now);
	
	    // Create a string stream to format the time
	    std::ostringstream oss;
	    oss << std::put_time(localTime, "%Y-%m-%d-%H:%M:%S");

	    return oss.str();
	}

private:
	std::string file_name_;
	std::ostream &os_;
	std::ofstream fd_;
	// Timer t_
};

int main()
{
	std::vector<std::tuple<uint, uint, uint>> tp 
		=
		{
			{16, 16, 16},
			{16, 16, 16},
			{16, 16, 16},
		};
	std::vector<float> cost_times
		=
		{
			{0.2},
			{0.3},
			{0.3},
		};

	Gen g_cout;
	std::vector<float> vf = {1.0, 2.0, 3.0};
	std::vector<kernel_function> funs;
	std::vector<std::tuple<uint, uint, uint>> shapes;
	uint M = 1, N = 1, K = 1;
	shapes.push_back({M, N, K});
	float *a = new float[1];
	float *b = new float[1];
	float *c = new float[1];
	funs.push_back(run_fun_kernel);
	g_cout.gen(funs,a, b, c, shapes);

	return 0;
}
